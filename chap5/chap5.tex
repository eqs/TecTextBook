\renewcommand{\myepsfbox}[1]{\epsfbox{chap5/#1}}

\chapter{プログラミング}

この章では，TeCのプログラミングを学習します．
まず，TeCの内部構成を勉強し，
ノイマン型コンピュータの例として，
TeCが適切であることを確認します．
次に，TeCの命令と，
それを使用したプログラムの作成を勉強します．
% この章の内容をマスターすれば，
% ノイマン型コンピュータがどのようなもので，
% 何ができて何ができないのか，
% はっきり分かってきます．

\section{コンピュータの構成}

% プログラミングを始める前に，
プログラミングの対象となるコンピュータの構成を確認します．
ここでは，一般のコンピュータの構成と，TeCの構成の両方を説明します．
TeCの構成は一般のコンピュータの構成を簡単化したもので，
原理的には同じものだと分かります．

\subsection{一般的なコンピュータの構成}

%11.8
\myfigureA{hbtp}{10.3cm}{kousei1.pdf}{一般的なコンピュータの構成}{chap5:kousei1}

一般的にパソコン等の構成は，
\figref{chap5:kousei1}のようになっています．
各部分の役割は次の通りです．

\begin{enumerate}
\item CPU(Central Processing Unit:中央処理装置) \\
命令を読み込んで，命令に従い計算をするコンピュータの心臓部です．
計算機能，制御機能を持っています．
CPUが他の部分に積極的に働きかけることにより，コンピュータが働きます．
\item 主記憶装置(メモリ) \\
プログラムやデータを記憶する記憶装置です．
CPUが高速に読み書きをすることができます．
\item 入出力インタフェース \\
入出力装置をコンピュータに接続するための回路です．
入出力装置の種類や機種毎に，専用のインターフェース回路が必要になります．
%(キーボード用のインタフェース回路，ディスプレイ用のインタフェース回路)
\item 入出力装置 \\
時計やコンピュータの外部とデータのやりとりをする装置のことです．
タイマ，キーボード，マウス，ディスプレイ，
プリンタや通信装置等がこれにあたります．
ハードディスクドライブやCD-ROMドライブ等も入出力装置の仲間ですが，
データを記憶する装置であるので少し性格が異なります．
そこで，これらは補助記憶装置と呼ばれることがあります．
\item バス \\
CPUと主記憶装置や入出力インタフェースを接続する配線のことです．
アドレスやデータ，制御信号等がバスで伝達されます．
CPUはバスを制御することにより，
バスに接続された装置とデータのやりとりをします．
\end{enumerate}

\subsection{TeCの構成}

%12.5
\myfigureA{htbp}{10.5cm}{kousei2.pdf}{TeCの構成}{chap5:kousei2}

TeC7の構成は\figref{chap5:kousei2}のようになっています．
接続されている入出力装置が少ない，
メモリの容量が小さい等の違いはありますが，
基本的には一般的なコンピュータと同じになっています．
% これらの大部分は，\figref{chap4:kakubu}の「マイコン本体」にある正方形のLSIの
% 内部に集積されています．
各部分の役割りは次の通りです．

\begin{enumerate}
\item CPU \\
TeCのCPUも計算機能，制御機能を持っています．
\figref{chap4:naibu}に示した{\bf フラグ}と{\bf レジスタ}はCPUの内部にあります．
\item 主記憶装置(メモリ) \\
TeCのメモリは，\figref{chap4:naibu}に示した8ビット構成，256アドレスのものです．
一つのアドレスに8ビットの情報を記憶することができます．
% 0〜255($00_{16}$〜$FF_{16}$)の範囲でアドレスを指定するためには，
% アドレス情報も8ビット必要ですので，
% 8ビットアドレスと呼ぶこともあります．
\item 入出力インタフェース \\
入出力インターフェース回路を通してバスと入出力装置が接続されます．
\item 入出力装置 \\
入出力装置として，シリアル通信回路，スピーカ，
コンソールパネルのデータスイッチ，タイマ，入出力ポートが搭載されています．
(TeC6には，タイマと入出力ポートがありません．)
\item バス \\
CPUと主記憶装置や入出力インタフェースの間で次の情報を伝達します．
\begin{enumerate}
\item 8ビットのアドレス
\item 8ビットのデータ
\item いくつかの制御情報
\end{enumerate}
\end{enumerate}

\section{機械語プログラミング}
機械語命令の羅列がプログラムです．
機械語命令の羅列を作る作業がプログラミングです．

\subsection{機械語命令}
コンピュータのCPUは，メモリから命令を取り出し，
取り出した命令を解釈し，決められた計算等を行います．
CPUが解釈できる状態の命令を，
「CPU＝機械」が解釈できる命令なので{\bf 「機械語命令」}と呼びます．
機械語命令は2進数でメモリに書き込みます．

2進数を用いた機械語の表現方法だけでは人間にとって分かり難いので，
命令を意味する英語を簡略化した短い綴で表します．
これを{\bf 「ニーモニック」}と呼びます．

{\tt
\begin{center}
\begin{tabular}{|c|c|c|} \hline
機械語命令 & ニーモニック & 意味\\
\hline
$0000~0000_{2}$ & NO & No Operation \\
$1111~1111_{2}$ & HALT & Halt \\
\hline
\end{tabular}
\end{center}
}

\subsection{ノイマン型コンピュータの特徴}
TeCもノイマン型コンピュータの一種です．
ノイマン型コンピュータの特徴として次の3点があげられますが，
これは，TeCにも当てはまります．
\begin{enumerate}
\item プログラム内蔵(ストアードプログラム)方式 \\
データだけでなく，プログラムもメモリに記憶する方式です．
TeCでもプログラムはメモリに書き込んで実行します．
\item 逐次実行 \\
プログラムの命令を，メモリのアドレス順に一つ一つ順番に実行することを言います．
\item 2進法 \\
コンピュータの内部では，プログラムやデータの表現に2進数を使います．
\end{enumerate}

\subsection{機械語プログラミング}
ノイマン型コンピュータ上での機械語プログラミングとは，
逐次実行により実行される順に機械語命令の羅列を作る作業のことです．
作ったプログラムは，2進数にしてメモリに書き込んで実行します．

TeCにどのような機械語命令があるかを，
次の節から種類別に説明します．

%=============================================================================
\section{特殊な命令}
まず，TeCの機械語命令の中で特別なものから説明します．

\subsection{NO(No Operation)命令}
\begin{flushleft}
{\bf 意味}：何もしない． \\
{\bf ニーモニック：}{\tt NO} \\
{\bf 命令フォーマット：}NO命令は，1バイト長の命令です．
\end{flushleft}
\begin{center}
\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} \\
\hline
OP & GR XR \\
\hline
$0000_2$ & $00~00_2$ \\
\hline
\end{tabular}
\end{center}
命令フォーマットは，
その機械語命令が2進数でどのように表現されるかを表します．
NO命令の場合，機械語が1バイトであること，その1バイトの内容が，
OPフィールド4ビットが$0000_2$，
GRフィールド2ビットが$00_2$，
XRフィールド2ビットが$00_2$であることが命令フォーマットの図から分かります．
NO命令以外の命令も，フィールドのビット数は同じです．

\subsection{HALT(Halt)命令}
\begin{flushleft}
{\bf 意味}：プログラム実行の終了． \\
{\bf ニーモニック：}{\tt HALT} \\
{\bf 命令フォーマット：}HALT命令は，1バイト長の命令です．
\end{flushleft}
\begin{center}
\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} \\
\hline
OP & GR XR \\
\hline
$1111_2$ & $11~11_2$ \\
\hline
\end{tabular}
\end{center}

\newpage
%=============================================================================
\section{データ転送命令}
TeCのCPUとメモリの間でデータ転送をする機械語命令を説明します．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{LD(Load)命令}
Loadは，「荷物等を積み込む」と言う意味の英語です．
LDは，Loadの綴を縮めたものです．

\begin{description}
\item[意味：]主記憶(メモリ)からレジスタへデータを転送します．
(メモリからレジスタへ値をコピーします．メモリの値は変化しません．) 

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt LD  GR,A[,XR]} \\
{\tt GR}は，転送先レジスタを表します．
{\tt A}はデータの置いてあるメモリのアドレス(番地)を表します．
{\tt [,XR]}は，省略可能です．
将来，きちんと説明するまで，
{\tt [,XR]}は常に省略(この部分を書かない)してください．

\item[命令フォーマット：]LD命令は2バイトの長さを持ちます．
命令の各ビットは次の通りです．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0001_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\begin{itemize}
\item OPフィールド(4ビット)はLD命令を示す $0001_2$にします．
\item GRフィールド(2ビット)はデータを格納するレジスタを表します．
GRフィールドの値は次の表のような意味を持ちます．

\begin{tabular}{|c|c|} \hline
 GR & 意味 \\
\hline
 00 & G0 \\
 01 & G1 \\
 10 & G2 \\
 11 & SP \\
\hline
\end{tabular}

\item XRフィールド(2ビット)は，
将来，詳しく説明するまでは常に''$00$''にします．
\item 第2バイト($aaaa~aaaa$)は，{\tt A}(番地)を2進数で格納します．
\end{itemize}

\item[フローチャート：]フローチャートでは，LD命令を次のように描きます．
{\tt [ と ]}を書き忘れないように，注意して下さい．
\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{ld.pdf}
\end{flushleft}

\item[使用例：]LD命令を使用したプログラムの例を示します．
なお，ニーモニック欄の数値は10進数ですので，注意してください．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
$00_{16}$ & $10_{16}$ $0A_{16}$ & & LD   & G0,10 \\
$02_{16}$ & $14_{16}$ $0B_{16}$ & & LD   & G1,11 \\
$04_{16}$ & $FF_{16}$           & & HALT &       \\
\hline
\end{tabular}
}

例の中で機械語は16進数で書いてありますが，
2進数に変換すると0番地の命令は $0001~0000_2$，$0000~1010_2$です．
上の命令フォーマットと対応を確認してください．

このプログラムをフローチャートで表現すると，
次のようになります．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{lds.pdf}
\end{flushleft}

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\vfill
%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 命令表}\\
TeCでどんな機械語命令が使用できるかは，
本体のケースに張り付けた命令表
(または，付録Cの命令表)により確認することができます．
これまでに出てきたNO，HALT，LD命令について，
命令表を確認して下さい．
ニーモニックと命令の名前，命令のフォーマットが分かりますね．

その他にも，まだ習っていない情報がたくさん掲載されています．
一通り勉強が終わったら，
この命令表だけでTeCを自由にプログラミングできるようになります．
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf RUNランプが点滅したら} \\
CPUが機械語命令として解釈できない命令を実行しようとしたことを表します．
PCが解釈できなかった命令の次の番地を指した状態でCPUが停止します．
PCの値からおかしな命令を見付けて訂正してください．
}}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{ST(Store)命令}
Storeは，「倉庫に保管する」と言う意味の英語です．
STは，Storeの綴を縮めたものです．

\begin{description}
\item[意味：]レジスタからメモリへデータを転送します．
(
%レジスタからメモリへ値をコピーします．
レジスタの値は変化しません．) 

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt ST  GR,A[,XR]} \\
{\tt GR}は，転送元レジスタを表します．
{\tt A}はデータを保管するメモリのアドレス(番地)を表します．
{\tt [,XR]}は，省略可能です．
将来，きちんと説明するまで，
{\tt [,XR]}は常に省略してください．

\item[命令フォーマット：]ST命令は2バイトの長さを持ちます．
命令のフォーマットは次の通りです．
各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0010_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]フローチャートでは，ST命令を次のように描きます．
{\tt [ と ]}を書き忘れないように，注意して下さい．
\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{st.pdf}
\end{flushleft}

\item[使用例：]
%LD命令とST命令を組み合わせて作った，
10番地のデータを11番地にコピーして停止するプログラムの例を示します．
番地と機械語の欄はいつも16進数で書くので，
この例から小さく16と書くのを止めます．
なお，ニーモニック欄の数値は10進数です．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 0A & & LD   & G0,10 \\
02 & 20 0B & & ST   & G0,11 \\
04 & FF    & & HALT & \\
\hline
\end{tabular}
}
\end{description}

%----------------------------------------------------------------------------
\subsubsection{問題}
以下では番地が16進数です．注意して下さい．
\begin{enumerate}
\item $11_{16}$番地のデータを$12_{16}$番地に，
$10_{16}$番地のデータを$11_{16}$番地にコピーして停止するプログラムを，
上の使用例のように書きなさい．
\item $10_{16}$番地のデータと$11_{16}$番地のデータを交換して
停止するプログラムを，上の使用例のように書きなさい．
\item これらのプログラムを，実際にTeCで実行して正しく動くことを確認しなさい．
\end{enumerate}

%----------------------------------------------------------------------------
%\vfill
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf プログラムの作成手順}\\
ST命令の使用例のように,
表を作成しながらプログラムを書きます．
手順は次の通りです．
\begin{enumerate}
\item 表の枠を書く．
\item ニーモニックでプログラムを書く．
プログラムに間違えが無いか，この段階で良く考える．
\item 機械語命令の長さを考えながら番地欄を記入する．
(これは，機械的な作業．ミスをしないよう慎重に．)
\item 機械語欄を記入する．
(これも，機械的な作業．ミスをしないように．)
\item 全部記入したら，TeCに打ち込んで実行してみる．
\item うまく動かなかったら，
全てのステップを再度確認し間違えを探す．
\item うまく動いたら完成！！！
(うまく動いたかどうかの確認も慎重に！)
\end{enumerate}

表に記入したら終わりではありません．
TeCに打ち込んで実際に動くことを確認してください．
動くはずなのに動かないことが多い(まず，動かないと考えた方が良い)です．

実際に動かし正しく動作することを確認できるまでは，
プログラムは完成していません．
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf RUNランプに注意} \\
RUNランプはプログラム実行中に点灯しています．
プログラムが暴走し終了しない時は，
RUNランプが点灯したままになります．
プログラム実行中でも，
コンソールパネルを操作してメモリやレジスタの値を表示できるので，
プログラムが暴走していることに気づかないことがあります．
RUNランプを常に気にするようにして下さい．
}}
\end{center}

%=============================================================================
\newpage
\section{算術演算命令}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{ADD(Add)命令}
ADDは名前の通り，加算をする命令です．

\begin{description}
\item[意味：]レジスタの値とメモリデータの和を計算し，
結果を元のレジスタに格納します．(メモリの値は変化しません．)

\item[フラグ：]計算の結果により変化します．

\item[ニーモニック：]{\tt ADD  GR,A[,XR]} \\
{\tt GR}は，足し算の対象になるレジスタを表します．
このレジスタの値とメモリの値が足し合わされ，
結果がこのレジスタに格納されます．
{\tt A}と{\tt [,XR]}の意味はLD命令と同様です．

\item[命令フォーマット：]ADD命令は2バイトの長さを持ちます．
命令の各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0011_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]フローチャートでは，ADD命令を次のように描きます．
{\tt [ と ]}を書き忘れないように，注意して下さい．
\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{add.pdf}
\end{flushleft}

\item[使用例：]
7番地のデータと8番地のデータの和を計算し，
9番地に格納するプログラムの例を示します．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 07 & & LD   & G0,7 \\
02 & 30 08 & & ADD  & G0,8 \\
04 & 20 09 & & ST   & G0,9 \\
06 & FF    & & HALT & \\
\hline
\end{tabular}
}

このプログラムを実行するときは，
予め7番地，8番地に足し合わせるデータを格納しておく必要があります．
例えば，7番地に1，8番地に2を格納してからこのプログラムを実行すると，
計算結果としてプログラムにより9番地に3が格納されます．

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{SUB(Subtract)命令}
Subtractは，「引き算をする」と言う意味の英語です．
SUBはSubtractの綴を縮めたものです．

\begin{description}
\item[意味：]レジスタの値とメモリデータの差を計算し，
結果を元のレジスタに格納します．(メモリの値は変化しません．)

\item[フラグ：]計算結果により変化します．

\item[ニーモニック：]{\tt SUB  GR,A[,XR]} \\
{\tt GR}は，引き算の対象になるレジスタを表します．
このレジスタの値からメモリの値が引かれ，
結果がこのレジスタに格納されます．
{\tt A}と{\tt [,XR]}の意味はLD命令と同様です．

\item[命令フォーマット：]SUB命令は2バイトの長さを持ちます．
命令の各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0100_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]SUB命令は次のように描きます．
%{\tt [ と ]}を書き忘れないように，注意して下さい．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{sub.pdf}
\end{flushleft}

\item[使用例：]
7番地のデータから8番地のデータを引いた結果を
9番地に格納するプログラムの例を示します．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 07 & & LD   & G0,7 \\
02 & 40 08 & & SUB  & G0,8 \\
04 & 20 09 & & ST   & G0,9 \\
06 & FF    & & HALT & \\
\hline
\end{tabular}
}

このプログラムを実行するときは，
予め7番地に引かれる数，8番地に引く数を格納しておく必要があります．
\end{description}
\subsubsection{問題}
$10_{16}$番地のデータと$11_{16}$番地のデータの和を$12_{16}$番地に，
差を$13_{16}$番地に格納するプログラムを作成し，
TeCで実行して正しく実行できたことを確かめなさい．

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf フラグ} \\
いくつかのプログラムを作成して動かして見ました．
そのとき，
TeCのC，S，Zランプが点灯したり消灯したりしたのが分かったでしょうか？
これらのランプは，対応したフラグ(Flag:旗)の値を表示しています．
どんなときランプが点灯し(フラグが1になり)，
どんなときランプが消灯した(フラグが0になった)のか説明します．

{\bf C(Carry)フラグ} \\
Carryは「桁を繰り上げる」と言う意味です．
Cフラグは，
計算中に8bitの最上位桁からの「桁上がり」や，
8bitの最上位桁での「桁借り」が発生したことを表します．
つまり，計算結果が255を超えてしまったことや，
0より小さくなったことを表します．
Cフラグは，計算値が符号無しと考えたときのオーバーフローを表しています．

{\bf S(Sign)フラグ} \\
Signは，{\bf 「符号」}を意味します．
計算の結果を符号付き2進数として解釈した場合，負の値になることを表します．
つまり，計算結果の8bitの最上位ビットが1のとき1になります．

{\bf Z(Zero)フラグ} \\
Zeroは，名前の通り計算の結果がゼロになったことを表します．
つまり，計算結果の8bitの全てのビットが0のとき1になります．

\vspace{0.2cm}
これら三つのフラグは，
命令表で「フラグ変化」の欄に「○」印が付いている演算命令を実行する度に，
計算結果によって変化します．
つまり，直前の演算の結果を反映しています．
これまでに出てきた命令では，ADD，SUBがフラグを変化させる命令です．
}}
\end{center}

%------------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf うまく動かない場合} \\
プログラムが正しく動かない人は，
1命令ずつ実行しながら，
メモリやレジスタの値が予想通りに変化するか調べて下さい．
1命令ずつ実行する方法は，\ref{step}中の「プログラムのステップ実行」に
説明してあります．

面倒くさいと思わないで，地道に問題点を捜しましょう．
問題点を見つけるコツが分かってきたら，
演習がすごく楽になります．
慣れるまで少し辛抱して下さい．
}}
\end{center}


%=============================================================================
\newpage
\section{ジャンプ命令}
ノイマン型コンピュータの特徴は逐次実行です．
命令を番地の順番に
%一つ一つ
順に実行します．
プログラムの実行が進んで行く流れを{\bf 「プログラムの流れ」}と言います．
プログラムの流れはPC(Program Counter)によって管理され，
通常はPCが順次増加します．

しかし，プログラムの同じ部分を繰り返したり，
条件によりプログラムの動きを変更する目的で，
流れを別の場所に飛ばす(Jump)ことも必要です．

ジャンプ命令はこのような目的でPCの値を変更し，
プログラムの流れを別の番地へ飛ばすものです．
プログラムの流れは飛んで行った先にあるプログラムを順番に実行する流れになり，
もとに戻って来ることはありません．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{JMP(Jump)命令}
この命令を実行するとプログラムの流れが，
必ず指定の番地にジャンプします．

\begin{description}
\item[意味：]プログラムの流れをジャンプさせます．
\item[フラグ：]変化しません．
\item[ニーモニック：]{\tt JMP A[,XR]} \\
{\tt A}はジャンプ先のアドレス(番地)を表します．
{\tt [,XR]}は，省略可能です．
将来，きちんと説明するまで，
{\tt [,XR]}は常に省略(この部分を書かない)してください．
\item[命令フォーマット：]JMP命令は2バイトの長さを持ちます．
GRフィールドは必ず $00$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1010_2$ & $00$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JMP命令はフローチャートの線に対応します．
次の命令で詳しく説明します．
%{\tt [ と ]}を書き忘れないように，注意して下さい．

%\begin{flushleft}
%\epsfxsize=3cm
%\myepsfbox{sub.pdf}
%\end{flushleft}

\item[使用例：]
$00$番地の命令を，いつまでも繰り返す(止まらない)プログラムの例を示します．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 30 04 & & ADD  & G0,4 \\
02 & A0 00 & & JMP  & 0    \\
\hline
\end{tabular}
}
\end{description}

%------------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf ラベル} \\
JMP命令の使用例では，
ジャンプする先のアドレスをニーモニックの中に直接書きました．
もしも，プログラムに変更があり，
ジャンプする先のアドレスが変化したらどうでしょうか．
プログラムに直接アドレスが書いてあると，それを書き直す必要が生じます．

番地が変化してもニーモニックで書いたプログラムを変更しなくて良いように，
アドレスの代わりにその場所に付けた記号を使うと便利です．

場所に付けた記号のことをラベルと言います．
ラベルを用いてプログラムを書き換えると次のようになります．

\begin{center}
{\small\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 30 04 & {\bf LOOP} & ADD  & G0,4          \\
02 & A0 00 &            & JMP  & {\bf LOOP}    \\
\hline
\end{tabular}
}
\end{center}
}}
\end{center}

%------------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf データの定義(DC命令)} \\
ラベルを用いることにより，
ニーモニックで書いたプログラムの取扱いが非常に便利になりました．
しかし，データの部分はニーモニックに記述できていません．
これでは，ニーモニックだけでプログラムの全体像が理解できません．

そこで，
データを記述するための``DC(Define Constant)''命令を追加します．
DC命令は，機械語の代わりにオペランドで指定した値のデータを生成します．
また，
DC命令の行にラベルを付けることによりデータもラベルで参照できるようになります．

次は，JMP命令の使用例をDC命令を用いて書き直したものです．
4番地に値``1''のデータがあることが，うまく記述できました．

\begin{center}
{\small\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 30 04 & LOOP       & ADD  & G0,{\bf ONE}  \\
02 & A0 00 &            & JMP  & LOOP          \\
04 & 01    & {\bf ONE}  & DC   & 1             \\
\hline
\end{tabular}
}
\end{center}
}}
\end{center}

%------------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 領域の定義(DS命令)} \\
DS命令はDC命令に良く似た命令です．
DC命令は機械語命令の代わりにデータを生成しました．
DS命令は結果を格納するための領域を生成します．
指定された数値は，領域の大きさになります．
}}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{JZ(Jump on Zero)命令}
Zフラグが1のとき(計算結果が0だったとき)だけジャンプします．

\begin{description}
\item[意味：]Zフラグが1ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt JZ A[,XR]} \\
JMP命令と同様です．

\item[命令フォーマット：]JZ命令は2バイトの長さを持ちます．
GRフィールドは必ず $01$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1010_2$ & $01$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JZ命令のフローチャートは，
次のように様々な描き方が考えられます．
例には，JMP命令と組合せて菱形一つに対応させたものもありますが，
こだわる必要はありません．
場合によって，柔軟にアレンジして下さい．

\begin{flushleft}
\epsfxsize=7cm
\myepsfbox{jz.pdf}
\end{flushleft}

\item[使用例：]
結果がゼロだったら停止するプログラムの例を示します．
定数の``1''を使用するためにDC命令でメモリの$07_{16}$番地に
データ$01_{16}$を置きました．
定数を使用するためにはメモリ上に定数データを置く必要があります．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 30 07 & LOOP & ADD  & G0,ONE  \\
02 & A4 06 &      & JZ   & STOP    \\
04 & A0 00 &      & JMP  & LOOP    \\
06 & FF    & STOP & HALT &         \\
07 & 01    & ONE  & DC   & 1       \\
\hline
\end{tabular}
}
\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\newpage
\subsection{JC(Jump on Carry)命令}
Cフラグが1のときだけジャンプします．

\begin{description}
\item[意味：]Cフラグが1ならジャンプします．
\item[フラグ：]変化しません．
\item[ニーモニック：]{\tt JC  A[,XR]} \\
JMP命令と同様です．
\item[命令フォーマット：]JC命令は2バイトの長さを持ちます．
GRフィールドは必ず $10$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1010_2$ & $10$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JC命令のフローチャートは，
JZ命令と同様な考えで描きます．
JZ命令を参考にして下さい．

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\newpage
\subsection{JM(Jump on Minus)命令}
Sフラグが1のとき(計算結果が負だったとき)だけジャンプします．
名前が，JS命令ではなくJM命令になっているので注意して下さい．

\begin{description}
\item[意味：]Sフラグが1ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt JM  A[,XR]} \\
JMP命令と同様です．

\item[命令フォーマット：]JM命令は2バイトの長さを持ちます．
GRフィールドは必ず $11$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1010_2$ & $11$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JM命令のフローチャートも，
JZ命令と同様な考えで描きます．
JZ命令を参考にして下さい．

\end{description}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 条件判断1}\\
ジャンプ命令を用いて，
条件判断があるプログラムを作ることができます．
次のフローチャートとプログラムは，
計算結果がゼロだった場合だけ処理をするものです．
このように，ある条件の場合だけ処理をするプログラムを作ることができます．

\begin{center}
\epsfxsize=7cm
\myepsfbox{flow2A.pdf}
\end{center}
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 条件判断2}\\
条件によって，
二つの処理のどちらかを選んで実行するプログラムを作ることができます．
次のフローチャートとプログラムは，
計算結果がゼロだった場合は「処理1」を，
ゼロ以外だった場合は「処理2」を実行します．

\begin{center}
\epsfxsize=7cm
\myepsfbox{flow2B.pdf}
\end{center}
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 繰り返し処理1}\\
次のように，
ジャンプ命令を用いて同じ操作を繰り返すプログラムを作ることができます．
次のフローチャートとプログラムは，点線部分を10回繰り返すためのものです．

\begin{center}
\epsfxsize=7cm
\myepsfbox{flow2.pdf}
\end{center}
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 繰り返し処理2}\\
計算結果によって繰り返し回数が決まる場合等，
繰り返し回数がゼロの場合も考慮しなければならないことがあります．
そのような場合は，条件判断を前に移動すると，うまく処理できます．
次のフローチャートとプログラムは，
点線部分をN回繰り返すためのものです．
条件判断の前の引算は，
G0の値でフラグを強制的に変化させるためのものです．

\begin{center}
\epsfxsize=7cm
\myepsfbox{flow2C.pdf}
\end{center}
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-1} 絶対値を求める．
\label{rei:5_1}
\begin{description}

\item[問題：]
N番地のデータの絶対値を計算し，
M番地に格納するプログラムを作りなさい．

\item[考え方：]
値が正なのか負なのかは，
値からゼロを(SUB命令で)引き，
そのときのフラグの変化で調べます．\\
負の値の絶対値は，
ゼロからその値を引くことで求めることができます．

\item[解答：]次のフローチャートのようなプログラムを作ります．

%\begin{figure}
%\begin{center}
\epsfxsize=6.6cm
%%\epsfysize=13.0cm
\myepsfbox{flow1.pdf}
%\caption{絶対値を求めるプログラム}
%\label{flow1}
%\end{center}
%\end{figure}

\begin{center}
{\footnotesize\tt
\begin{tabular}{|l|l|l|l l|}
\hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 10 & START& LD   & G0,N    \\
02 & 40 0F &      & SUB  & G0,ZERO \\
04 & AC 08 &      & JM   & L1      \\
06 & A0 0C &      & JMP  & L2      \\
08 & 10 0F & L1   & LD   & G0,ZERO \\
0A & 40 10 &      & SUB  & G0,N    \\
0C & 20 11 & L2   & ST   & G0,M    \\
0E & FF    &      & HALT &         \\
0F & 00    & ZERO & DC   & 0       \\
10 & FF    & N    & DC   & -1      \\
11 & 00    & M    & DS   & 1       \\
\hline
\end{tabular}
}
\end{center}

\item[解説：]プログラムの内容を説明します．
{\small
\begin{description}
\item[(1)] G0レジスタに値をロードします．
\item[(2)] G0レジスタから0を引きます．
値は変化しませんが，計算結果によりフラグが変化します．
\item[(3)] JM命令はSフラグの値によりジャンプします．
\item[(4)，(5)] この部分は，値が負だった場合のみ実行されます．
$0 - [N番地]$を計算し，値の絶対値をG0に求めます．
\item[(6)] G0の値をM番地に格納します．
\end{description}
}

\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-2} $1 + 2 + 3 + ... + 10$を計算する．
\label{rei:5_2}
\begin{description}
\item[問題：]
$1 + 2 + 3 + ... + 10$を計算し結果をSUM番地に求めるプログラムを作りなさい．

\item[考え方：]
G0以外に，G1，G2，SPの三つのレジスタが自由に使用できるので，
それぞれのレジスタに足す値を記憶する，合計を記憶する等の役割りを分担させ，
繰り返し(10回繰り返す)をうまく利用すると計算できます．

TeCにはレジスタの値同士を足し算する命令がありません．
一方のレジスタ値をメモリに格納してから，足し算する必要があります．

\item[解答：]
G0を繰り返し回数のカウント，
G1をレジスタに足す数の記憶(1,2,3,...,10)，
G2を合計の記憶に使用することにしました．
フローチャートとプログラムは次のようになります．
%\begin{figure}
\begin{center}
\epsfxsize=6.6cm
%%\epsfysize=13.0cm
\myepsfbox{flow3.pdf}
%\caption{1〜10の合計を求める}
%\label{flow3}
\end{center}
%\end{figure}
\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf Cフラグの詳しい説明} \\

Cフラグは，
計算中に，8bitの最上位桁からの「桁上がり(Carry)」が発生したことや，
8bitの最上位桁での「桁借り(Borrow)」が発生したことを表します．
例えば，次の計算では最上位桁からの「桁上がり」は発生しませんので，
Cフラグは``0''になります．
\begin{center}
\begin{tabular}{ c l l}
     & $0000~0001_2$ & (1) \\
 $+$ & $0000~0011_2$ & (3) \\
\cline{1-2}
\fbox{$0$} & $0000~0100_2$ & (4) \\
 C  &                     \\
\end{tabular}
\end{center}
次の計算では最上位桁からの「桁上がり」が発生し，Cフラグが``1''になります．
Cフラグは，計算値が符号無しと考えたときのオーバーフローを表しています．
\begin{center}
\begin{tabular}{ c l r r }
     &               & 符号無 & 符号付 \\
     & $1111~1111_2$ & (255)  & (-1) \\
 $+$ & $0000~0001_2$ & (1)    & (+1)\\
\cline{1-2}
\fbox{$1$} & $0000~0000_2$ & (オーバ & (0) \\
       C   &               & フロー) & \\
\end{tabular}
\end{center}

また，引き算でもCフラグが1になることがあります．
例えば，次のように小さな数から大きな数を引いた場合です．
機械的に引き算をすると，最上位桁で桁借りが発生します．
この時も，Cフラグが1になります．
\begin{center}
\begin{tabular}{ c l r r }
     &               & 符号無 & 符号付 \\
     & $0110~0100_2$ & (100)  & (+100) \\
 $-$ & $0110~1110_2$ & (110)  & (+110)\\
\cline{1-2}
\fbox{$1$} & $1111~0110_2$ & (オーバ & (-10) \\
       C   &               & フロー) & \\
\end{tabular}
\end{center}

このように引き算の場合は，
Cフラグは，計算が符号無しと考えたときの，
負へのオーバーフローを表しています．
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\subsection{JNZ(Jump on Not Zero)命令}
Zフラグが0のとき(計算結果がゼロ以外だったとき)だけジャンプします．
\\({\bf 注意：}TeC7で新たに追加された命令です．TeC6では使用できません．)

\begin{description}
\item[意味：]Zフラグが0ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt JNZ  A[,XR]} \\
JMP命令と同様です．

\item[命令フォーマット：]JNZ命令は2バイトの長さを持ちます．
GRフィールドは必ず $01$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1011_2$ & $01$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JNZ命令のフローチャートも，
JZ命令と同様な考えで描きます．
JZ命令を参考にして下さい．

\item[使用例：]
JZ命令の{\bf 使用例}で紹介した「結果がゼロだったら停止するプログラムの例」を
JNZ命令を使用して書き直しました．
JNZ命令を使用したほうが随分シンプルになります．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 30 05 & LOOP & ADD  & G0,ONE  \\
02 & B4 00 &      & JNZ  & LOOP    \\
04 & FF    &      & HALT &         \\
05 & 01    & ONE  & DC   & 1       \\
\hline
\end{tabular}
}
\end{description}

%----------------------------------------------------------------------------
\subsection{JNC(Jump on Not Carry)命令}
Cフラグが0のときだけジャンプします．
\\({\bf 注意：}TeC7で新たに追加された命令です．TeC6では使用できません．)

\begin{description}
\item[意味：]Cフラグが0ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt JNC  A[,XR]} \\
JMP命令と同様です．

\item[命令フォーマット：]JNC命令は2バイトの長さを持ちます．
GRフィールドは必ず $10$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1011_2$ & $10$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JNC命令のフローチャートも，
JZ命令と同様な考えで描きます．
JZ命令を参考にして下さい．

\end{description}

%----------------------------------------------------------------------------
\subsection{JNM(Jump on Not Minus)命令}
Sフラグが0のとき(計算結果がゼロか正だったとき)だけジャンプします．
名前が，JNS命令ではなくJNM命令になっているので注意して下さい．
\\({\bf 注意：}TeC7で新たに追加された命令です．TeC6では使用できません．)

\begin{description}
\item[意味：]Sフラグが0ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt JNM  A[,XR]} \\
JMP命令と同様です．

\item[命令フォーマット：]JNM命令は2バイトの長さを持ちます．
GRフィールドは必ず $11$にします．
第2バイトがジャンプ先のアドレスを示します．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1011_2$ & $11$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]JNM命令のフローチャートも，
JZ命令と同様な考えで描きます．
JZ命令を参考にして下さい．

\end{description}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item かけ算プログラム \\
N番地とM番地の値のかけ算を計算し，
L番地に結果を格納するプログラムを作りなさい．
%{\bf ヒント：かけ算は足し算の繰り返しでできます．}
\item かけ算プログラムの改良 \\
前のプログラムを[N]または，
[M]がゼロのときでも正しく動くように改良しなさい．
\end{enumerate}

%=============================================================================
\newpage
\section{比較命令}
\label{comp}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{CMP(Compare)命令}
Compareは，「比較をする」と言う意味の英語です．
CMPはCompareの綴を縮めたものです．
比較は引き算により行います．
レジスタの値からメモリの値を引いて，
その結果によりフラグを変化させます．
引き算結果そのものは，どこにも格納しないで捨てます．

\begin{description}
\item[意味：]レジスタの値とメモリデータを比較します．
引き算の結果により，フラグだけが変化します．

\item[フラグ：]計算結果により変化します．

\item[ニーモニック：]{\tt CMP  GR,A[,XR]} \\
{\tt GR}で指定されたレジスタの値と，メモリの値が比較されます．
{\tt A}と{\tt [,XR]}の意味はLD命令と同様です．

\item[命令フォーマット：]CMP命令は2バイトの長さを持ちます．
各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0101_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]CMP命令は次のように描きます．
%{\tt [ と ]}を書き忘れないように，注意して下さい．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{cmp.pdf}
\end{flushleft}

\item[使用例：]
A，B二つのデータで大きい方を選んで，Cに格納するプログラムの例です．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 0D &    & LD   & G0,A \\
02 & 50 0E &    & CMP  & G0,B \\
04 & AC 08 &    & JM   & LB   \\
06 & A0 0A &    & JMP  & LC   \\
08 & 10 0E & LB & LD   & G0,B \\
0A & 20 0F & LC & ST   & G0,C \\
0C & FF    &    & HALT & \\
0D & 64    & A  & DC   & 100  \\
0E & C8    & B  & DC   & 200  \\
0F & 00    & C  & DS   & 1    \\
\hline
\end{tabular}
}
\end{description}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-3} 割算を計算する．
\label{rei:5_3}
\begin{description}
\item[問題：]
M番地の値をN番地の値で割り，
商をK番地，余りをL番地に求めるプログラムを作りなさい．

\item[考え方：]
TeCには割算命令がありません．
割算は引き算の繰り返しで計算できます．
割られる数から，割る数を引くことを繰り返します．
引くことができなくなったら終了します．
このとき，引いた回数が商，引いた結果が余りになります．

\item[解答：]
フローチャートとプログラムは次のようになります．\\

%\begin{figure}
%\begin{center}
\epsfxsize=6.6cm
%%\epsfysize=13.0cm
\myepsfbox{flow5.pdf}
%\caption{割算}
%\label{flow5}
%\end{center}
%\end{figure}

\item[解説：]CMP命令とJM命令でG0がN番地のデータより大きいか
確認してから，引き算を実行します．


\end{description}
}}
\end{center}


%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
以前の，絶対値を求めるプログラムをCMP命令を用いて書き直しなさい．
\vfill

%=============================================================================
\newpage
\section{シフト(桁ずらし)命令}
データの2進数を左右に桁移動する命令をシフト命令と言います．
TeCは以下に説明する4種類のシフト命令を持っています．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{SHLA{\small (Shift Left Arithmetic)}命令}
左算術(算術＝Arithmetic)シフトと言います．
レジスタのデータを左方向に1ビットずらします．
右側から常に``0''が入力されます．
左にはみ出したビットは，Cフラグの値になります．

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{shft1.pdf}
%\caption{SHLA命令の動作}
%\label{shft1}
\end{center}
%\end{figure}

\begin{description}
\item[意味：]レジスタの値を，左に1ビット，算術シフトします．

\item[フラグ：]Cフラグは上の説明のように，
S，Zフラグは計算結果により変化します．

\item[ニーモニック：]{\tt SHLA  GR} \\
{\tt GR}が，シフトされるレジスタを表します．
{\tt GR}の値とレジスタの対応は，LD命令等と同じです．

\item[命令フォーマット：]SHLA命令は1バイトの命令です．
XRフィールドは必ず $00$にします．

\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} \\
\hline
OP & GR XR \\
\hline
$1001_2$ & $GR$~$00$ \\
\hline
\end{tabular}

\item[フローチャート：]SHLA命令は次のように描くことにします．
なお，この書き方は，Java言語やC言語のシフト演算子を真似たものです．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{shla.pdf}
\end{flushleft}

\item[使用例：]
A番地のデータを2ビット左にシフトし，B番地に格納する例です．
左に2ビットシフトすることは，×4を計算したのと同じ結果になります．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 07 &   & LD   & G0,A \\
02 & 90    &   & SHLA & G0   \\
03 & 90    &   & SHLA & G0   \\
04 & 20 08 &   & ST   & G0,B \\
06 & FF    &   & HALT &      \\
07 & 01    & A & DC   & 1    \\
08 & 00    & B & DS   & 1    \\
\hline
\end{tabular}
}
\end{description}


%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{SHLL{\small (Shift Left Logical)}命令}
左論理(論理=Logical)シフトと言います．
この命令は SHLA と全く同じ動作をします．
(左シフトでは，算術と論理の差はない)

\begin{description}
\item[意味：]レジスタの値を，左に1ビット，論理シフトします．

\item[フラグ：]
SHLA命令と同様です．

\item[ニーモニック：]{\tt SHLL  GR} \\
SHLA命令と同様です．

\item[命令フォーマット：]SHLL命令は1バイトの命令です．
XRフィールドは必ず $01$にします．

\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} \\
\hline
OP & GR XR \\
\hline
$1001_2$ & $GR$~$01$ \\
\hline
\end{tabular}

\item[フローチャート：]SHLL命令は次のように描くことにします．
SHLA命令と全く同じ動作をするので，
フローチャートの描き方も，
SHLA命令と全く同じです．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{shla.pdf}
\end{flushleft}

\item[使用例：]
SHLA命令と同じ動作をする命令なので，
省略します．

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{SHRA{\small (Shift Right Arithmetic)}命令}
右算術(算術＝Arithmetic)シフトと言います．
レジスタのデータを右方向に1ビットずらします．
左側からシフト前のデータの最上位ビット(符号ビット)と同じ値が入力されます．
右にはみ出したビットは，Cフラグの値になります．

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{shft2.pdf}
%\caption{SHRA命令の動作}
%\label{shft1}
\end{center}
%\end{figure}

\begin{description}
\item[意味：]レジスタの値を，右に1ビット，算術シフトします．

\item[フラグ：]
SHLA命令と同様です．

\item[ニーモニック：]{\tt SHRA  GR} \\
SHLA命令と同様です．

\item[命令フォーマット：]SHRA命令は1バイトの命令です．
XRフィールドは必ず $10$にします．

\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} \\
\hline
OP & GR XR \\
\hline
$1001_2$ & $GR$~$10$ \\
\hline
\end{tabular}

\item[フローチャート：]SHRA命令は次のように描くことにします．
%なお，この書き方は，Java言語やC言語のシフト演算子を真似たものです．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{shra.pdf}
\end{flushleft}

\item[使用例：]
A，B番地のデータを1ビット右にシフトし，C，D番地に格納します．
右1ビットシフトと，÷2は同じ結果になります．
算術シフトの場合は，負の数でも正しく $1/2$ になります．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 0B &   & LD   & G0,A \\
02 & 92    &   & SHRA & G0   \\
03 & 20 0D &   & ST   & G0,C \\
05 & 14 0C &   & LD   & G1,B \\
07 & 96    &   & SHRA & G1   \\
08 & 24 0E &   & ST   & G1,D \\
0A & FF    &   & HALT &      \\
0B & 08    & A & DC   & 8    \\
0C & F8    & B & DC   & -8   \\
0D & 00    & C & DS   & 1    \\
0E & 00    & D & DS   & 1    \\
\hline
\end{tabular}
}
\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{SHRL{\small (Shift Right Logical)}命令}
右論理(論理＝Logical)シフトと言います．
レジスタのデータを右方向に1ビットずらします．
左側から``0''が入力されます．
右にはみ出したビットは，Cフラグの値になります．

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{shft3.pdf}
%\caption{SHRL命令の動作}
%\label{shft1}
\end{center}
%\end{figure}

\begin{description}
\item[意味：]レジスタの値を，右に1ビット，論理シフトします．

\item[フラグ：]
SHLA命令と同様です．

\item[ニーモニック：]{\tt SHRL  GR} \\
SHLA命令と同様です．

\item[命令フォーマット：]SHRL命令は1バイトの命令です．
XRフィールドは必ず $11$にします．

\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} \\
\hline
OP & GR XR \\
\hline
$1001_2$ & $GR$~$11$ \\
\hline
\end{tabular}

\item[フローチャート：]SHRL命令は次のように描くことにします．
%なお，この書き方は，Java言語のシフト演算子を真似たものです．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{shrl.pdf}
\end{flushleft}

\item[使用例：]
A，B番地のデータを1ビット右にシフトし，C，D番地に格納します．
右1ビットシフトと，÷2は同じ結果になります．
論理シフトの場合は，128以上の大きな数でも正しく $1/2$ の値になります．

{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 0B &   & LD   & G0,A \\
02 & 93    &   & SHRL & G0   \\
03 & 20 0D &   & ST   & G0,C \\
05 & 14 0C &   & LD   & G1,B \\
07 & 97    &   & SHRL & G1   \\
08 & 24 0E &   & ST   & G1,D \\
0A & FF    &   & HALT &      \\
0B & 7F    & A & DC   & 127  \\
0C & 80    & B & DC   & 128  \\
0D & 00    & C & DS   & 1    \\
0E & 00    & D & DS   & 1    \\
\hline
\end{tabular}
}
\end{description}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-4} シフトの動作確認
\label{rei:5_4}
\begin{description}
\item[問題：] 4種類のシフト命令について，
G0レジスタの値をシフトしながら動作を確認しなさい．

\item[プログラム：]
次のプログラムを作成します．

\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 90    & L0  & SHLA & G0     \\
01 & FF    &     & HALT &        \\
02 & A0 00 &     & JMP  & L0     \\
\hline
\end{tabular}
}
\end{center}

\item[フローチャート：] フローチャートで描く場合は，
次のように HALT を表現することにします．

\begin{center}
\epsfxsize=3.5cm
\myepsfbox{flow4A.pdf}
\end{center}


\item[実行方法：] 次の手順で実行します．
\begin{enumerate}
\item PCを$00_{16}$にする．
\item G0レジスタに適当なデータを書き込む．
\item ロータリースイッチをG0に合わせたまま，RUNボタンを押す．
\item G0の値がシフトされたことが，データランプで確認できる．
\item 再度，RUNボタンを押す．
\item G0の値が更にシフトされる．
\end{enumerate}

一度RUNボタンを押すとHALT命令で停止します．
そのとき，PCはJMP命令を指していますので，
再度RUNボタンを押すと，
もう一度，最初からプログラムが実行されます．
\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-5} ビットの回転
\label{rei:5_5}
\begin{description}
\item[問題：] 次の図のように，
G0レジスタの値を1ビット左回転するプログラムを作りなさい．

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{shft4.pdf}
%\caption{ビットの回転}
%\label{shft1}
\end{center}
%\end{figure}

\item[考え方：]
TeCには，ビットを回転する命令がありません．
次の手順で目的を達成します．
\begin{enumerate}
\item シフト命令でG0を1ビットシフトする．
\item はみ出したビットがCフラグに保存されているので，
Cフラグを調べる．
\item Cフラグが1だった場合は，G0最下位ビットを1にする．
\end{enumerate}

\begin{center}
\epsfxsize=3.5cm
\myepsfbox{flow4.pdf}
\end{center}

\item[プログラム：]
プログラムにすると次のようになります．
例題5-4と同様に，最後にJMP命令を追加しました．

\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 91    & L0  & SHLL & G0     \\
01 & A8 05 &     & JC   & L1     \\
03 & A0 07 &     & JMP  & L2     \\
05 & 30 0A & L1  & ADD  & G0,ONE \\
07 & FF    & L2  & HALT &        \\
08 & A0 00 &     & JMP  & L0     \\
0A & 01    & ONE & DC   & 1      \\
\hline
\end{tabular}}
\end{center}

\item[実行方法：] 例題5-4と同様です．
実行する度に，データランプの表示が回転します．
\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-6} シフトを用いた高速乗算
\label{rei:5_6}
\begin{description}
\item[問題：] シフトを用いて，
Aの10倍の値をBに求めるプログラムを作りなさい．

\item[考え方：]
TeCには，かけ算命令がありません．
そのため，繰り返しでかけ算をする方法を，以前，紹介しました．
ここでは，繰り返しによる方法より高速なかけ算を紹介します．

×10は，次の式のように変形できます．

\begin{center}
$B = A \times 10 = A \times 8 + A \times 2$
\end{center}

×2は，1ビット左にシフトすることと同じです．
×8は，3ビット左にシフトすることと同じです．
シフトした結果同士を足し合わせることにより，10倍を計算することができます．

\item[プログラム：]
プログラムにすると次のようになります．
TMPは，一時的にAの2倍の値を記憶するために使用します．

\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 0C &     & LD   & G0,A   \\
02 & 90    &     & SHLA & G0     \\
03 & 20 0E &     & ST   & G0,TMP \\
05 & 90    &     & SHLA & G0     \\
06 & 90    &     & SHLA & G0     \\
07 & 30 0E &     & ADD  & G0,TMP \\
09 & 20 0D &     & ST   & G0,B   \\
0B & FF    &     & HALT &        \\
0C & 03    & A   & DC   & 3      \\
0D & 00    & B   & DS   & 1      \\
0E & 00    & TMP & DS   & 1      \\
\hline
\end{tabular}
}
\end{center}

\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item Aの値の7倍をBに求めるプログラムを作りなさい．
\item Aのデータが符号無し2進数の場合，
Aの $1/4$ をBに求めるプログラムを作りなさい．
\end{enumerate}
\vfill

%=============================================================================
\newpage
\section{論理演算命令}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{AND(Logical AND)命令}
AND命令は，
レジスタとメモリデータのビット毎の論理積(AND)を計算します．
ビット毎の論理積とは，次の図のように，
レジスタとメモリの対応するビット同士の論理積の計算のことです．
計算結果はレジスタに格納されます．

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{land.pdf}
%\caption{ビット毎の論理積}
%\label{shft1}
\end{center}
%\end{figure}

\begin{description}
\item[意味：]ビット毎の論理積を計算します．
結果は元のレジスタに格納します．(メモリの値は変化しません．)

\item[フラグ：]Cフラグは常に0になります．
S，Zフラグは計算の結果により変化します．

\item[ニーモニック：]{\tt AND  GR,A[,XR]} \\
{\tt GR}は，計算の対象になるレジスタを表します．
このレジスタの値とメモリの値の論理積が計算されます．
結果はこのレジスタに格納されます．
{\tt A}と{\tt [,XR]}の意味はLD命令と同様です．

\item[命令フォーマット：]AND命令は2バイトの長さを持ちます．
各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0110_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]AND命令は次のように描くことにします．
これも，Java言語やC言語の演算子を真似したものです．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{and.pdf}
\end{flushleft}

\newpage
\item[使用例：]
A番地のデータとB番地のデータの論理積を計算し，
C番地に格納するプログラムの例を示します．

\begin{center}
{\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 07 &   & LD   & G0,A \\
02 & 60 08 &   & AND  & G0,B \\
04 & 20 09 &   & ST   & G0,C \\
06 & FF    &   & HALT &      \\
07 & 63    & A & DC   & 63H  \\
08 & 0F    & B & DC   & 0FH  \\
09 & 00    & C & DS   & 1    \\
\hline
\end{tabular}
}
\end{center}


%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{land1.pdf}
%\caption{ビット毎の論理積}
%\label{shft1}
\end{center}
%\end{figure}

\item[AND命令の応用：]
AND命令は，データの特定のビットを0にクリアしたり，
データの特定のビットの 1/0 を確かめたり，
データの一部のビットだけを取り出したりするために使用できます．

\begin{enumerate}
\item G0の最下位ビット(LSB)がゼロならL1へジャンプする．
\begin{center}
{\small\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
\cline{1-3}
    & ...  &        & \\
    & AND  & G0,ONE & \\
    & JZ   & L1     & \\
    & ...  &        & \\
L1  & ...  &        & \\
    & ...  &        & \\
ONE & DC   & 01H    & \\
\cline{1-3}
\end{tabular}
}
\end{center}
$01_{16}$とのANDの結果が$00_{16}$になることから，
LSBが$0$だったことが分かります．

\item G0の，b3,b2の2ビットを右詰めにして取り出す．
\begin{center}
{\small\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
\cline{1-3}
    & ...  &        & \\
    & AND  & G0,MSK & \\
    & SHRL & G0     & \\
    & SHRL & G0     & \\
    & ...  &        & \\
MSK & DC   & 0CH    & \\
\cline{1-3}
\end{tabular}
}
\end{center}

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{land2.pdf}
%\caption{ビット毎の論理積}
%\label{shft1}
\end{center}
%\end{figure}

\item G0の値を8の倍数になるように切り捨てる．

\begin{center}
{\small\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
\cline{1-3}
    & ...  &        & \\
    & AND  & G0,MSK & \\
    & ...  &        & \\
MSK & DC   & F8H    & \\
\cline{1-3}
\end{tabular}
}
\end{center}

下3ビットをゼロにすると，
8の倍数になります．

\item G0の値を8で割った余りを求める．

\begin{center}
{\small\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
\cline{1-3}
    & ...  &        & \\
    & AND  & G0,MSK & \\
    & ...  &        & \\
MSK & DC   & 07H    & \\
\cline{1-3}
\end{tabular}
}
\end{center}

下3ビットだけを取り出すと，
8で割った余りになります．

\vspace{0.3cm}

このように，2の累乗(2,4,8,16,...)で割った商や余りは，
シフトや論理演算で簡単に計算できます．
また，2の累乗の倍数に切捨てたり，
切り上げたりする計算も，
論理演算を使うと簡単にできます．

\end{enumerate}
\end{description}

%----------------------------------------------------------------------------
\vfill
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 16進数の表記} \\
ニーモニック中で数値を書くとき，
16進数で書き表したいことがあります．
そのときは，前のプログラム中のDC命令のように，
数値の後ろに``H''を付けます．
}}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{OR(Logical OR)命令}
OR命令は，
レジスタとメモリデータの対応するビット同士の論理和(OR)を計算します．
%AND命令の論理和版です．
計算結果はレジスタに格納されます．

\begin{description}
\item[意味：]ビット毎の論理和を計算します．
結果は元のレジスタに格納します．(メモリの値は変化しません．)

\item[フラグ：]Cフラグは常に0になります．
S，Zフラグは計算の結果により変化します．

\item[ニーモニック：]{\tt OR  GR,A[,XR]} \\
{\tt GR}は，計算の対象になるレジスタを表します．
このレジスタの値とメモリの値の論理和が計算されます．
結果はこのレジスタに格納されます．
{\tt A}と{\tt [,XR]}の意味はLD命令と同様です．

\item[命令フォーマット：]OR命令は2バイトの長さを持ちます．
各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$0111_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]OR命令は次のように描くことにします．
これも，Java言語やC言語の演算子を真似したものです．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{or.pdf}
\end{flushleft}

\item[OR命令の応用：]
OR命令は，データの特定のビットを1にするために使用できます．
次の例は，G0の上位4ビットを全て1にします．

\begin{center}
{\small\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
\cline{1-3}
    & ...  &        & \\
    & LD   & G0,DATA& \\
    & OR   & G0,MSK & \\
    & ...  &        & \\
DATA& DC   & 0AAH    & \\
MSK & DC   & 0F0H    & \\
\cline{1-3}
\end{tabular}
}
\end{center}

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{lor.pdf}
%\caption{ビット毎の論理和}
%\label{shft1}
\end{center}
%\end{figure}

\end{description}

%----------------------------------------------------------------------------

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{XOR(Logical XOR)命令}
XOR命令は，
レジスタとメモリデータの対応するビット同士の排他的論理和(XOR)を計算します．
計算結果はレジスタに格納されます．

\begin{description}
\item[意味：]ビット毎の排他的論理和を計算します．
結果は元のレジスタに格納します．(メモリの値は変化しません．)

\item[フラグ：]Cフラグは常に0になります．
S，Zフラグは計算の結果により変化します．

\item[ニーモニック：]{\tt XOR  GR,A[,XR]} \\
{\tt GR}は，計算の対象になるレジスタを表します．
このレジスタの値とメモリの値の排他的論理和が計算されます．
結果はこのレジスタに格納されます．
{\tt A}と{\tt [,XR]}はLD命令と同様です．

\item[命令フォーマット：]XOR命令は2バイトの長さを持ちます．
各フィールドの意味は，LD命令と同様です．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1000_2$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}

\item[フローチャート：]XOR命令は次のように描くことにします．
%これも，Java言語やC言語の演算子を真似したものです．

\vspace{-0.2cm}
\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{xor.pdf}
\end{flushleft}
\vspace{-0.2cm}

\item[XOR命令の応用：]
XOR命令を使用してデータの特定ビットの0/1を反転できます．
TeCにはNOT命令がないのでXOR命令で代用します．
次はG0の上位4ビットの0/1を反転します．

\begin{center}
{\small\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
\cline{1-3}
    & ...  &        & \\
    & LD   & G0,DATA& \\
    & XOR  & G0,MSK & \\
    & ...  &        & \\
DATA& DC   & 0AAH    & \\
MSK & DC   & 0F0H    & \\
\cline{1-3}
\end{tabular}
}
\end{center}

%\begin{figure}
\begin{center}
\epsfxsize=5cm
%%\epsfysize=13.0cm
\myepsfbox{lxor.pdf}
%\caption{ビット毎の排他的論理和}
%\label{shft1}
\end{center}
%\end{figure}

\end{description}

%----------------------------------------------------------------------------

%=============================================================================
\newpage
\section{アドレッシングモード}
LD，ST，ADD，SUB，CMP，AND，OR，XOR，
JMP，JZ，JC，JM，JNZ，JNC，JNM命令は，
どれも次のような同じフォーマットでした．
これまで，これらの命令の $XR$ 部分は $00$ にしてきました．

\begin{center}
\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$OP$ & $GR$~$XR$ & aaaa aaaa \\
\hline
\end{tabular}
\end{center}

$XR$に$00$以外を指定することにより，
メモリアドレス表現方法を変更することができます．
このアドレス表現方法のことをアドレッシングモードと呼びます．
TeCで使用できるアドレッシングモードは，
$XR$の値により次の4種類があります．

{\small
\begin{center}
\begin{tabular}{|c|l l|}
\hline
XR & \multicolumn{2}{|c|}{意味} \\
\hline
00 & ダイレクトモード     & (直接モード)   \\
01 & G1インデクスドモード & (G1指標モード) \\
10 & G2インデクスドモード & (G2指標モード) \\
11 & イミディエイトモード & (即値モード)   \\
\hline
\end{tabular}
\end{center}
}
(同様な表が命令表にも掲載されているので，
そちらも確認してください．)

以下ではLD命令とST命令を例に，
4種類のアドレッシングモードを説明します．
ここでは説明しませんが，
ADD， SUB， CMP， AND， OR， XOR命令でも，
LD命令やST命令と同様にアドレッシングモードが使用できます．


\subsection{ダイレクト(直接)モード}
これまで使用してきたのは，このモードです．
命令の第2バイトがメモリアドレスを直接に表します．

ニーモニックでは次のように書きました．
ここで，A，Bは，データを置いたメモリのアドレスです．

\begin{center}
{\tt
\begin{tabular}{l l}
LD & G0,A \\
ST & G0,B \\
\end{tabular}
}
\end{center}

フローチャートでは，次のように描きました．

\begin{center}
\epsfxsize=3cm
\myepsfbox{flowE.pdf}
\end{center}

\subsection{インデクスド(指標)モード}
G1またはG2レジスタの値と，
命令の第2バイトの値の合計がメモリアドレスを表します．
$XR$の値により，G1，G2どちらのレジスタを使用するか決まります．
G0レジスタは使用できないので注意してください．

このモードは，配列データをアクセスするとき使用できます．
また，ジャンプ命令でも使用できます．
ジャンプ命令でインデクスドモードを使用する方法は，
「\ref{jmptbl} ジャンプテーブル」で説明します．

ニーモニックでは次のように書きます．
このプログラムは，
$A+G1$番地のデータをG0に読込み，
$A+G2$番地に格納しています．

\begin{center}
{\tt
\begin{tabular}{l l}
LD & G0,A,G1 \\
ST & G0,A,G2 \\
\end{tabular}
}
\end{center}

フローチャートでは，次のように描きます．

\begin{center}
\epsfxsize=3cm
\myepsfbox{flowF.pdf}
\end{center}

\subsection{イミディエイト(即値)モード}
第2バイトがデータそのものになるモードです．
ST命令やジャンプ命令では使用できません．
(これらの命令で$XR$を$11$にすると，
CPUが命令を実行しようとしたとき，
命令コードのエラーになりRUNランプが点滅します．)

ニーモニックでは次のように書きます．
\begin{center}
{\tt
\begin{tabular}{l l}
LD & G0,\#1       \\
LD & G1,\#A       \\
\end{tabular}
}
\end{center}
最初のLD命令は，G0を1にします．
次のLD命令は，G1をAの番地(内容ではない)にします．
フローチャートでは，次のように描きます．

\begin{center}
\epsfxsize=3cm
\myepsfbox{flowG.pdf}
\end{center}

\subsection{アドレッシングモードの使用例}
A番地のデータで，
B番地からの10バイトの配列を初期化するプログラムの例を示します．

G1，G2レジスタを初期化する部分，
G1，G2レジスタの値を±1する部分にイミディエイトモードを使用しました．

また，10回の繰り返しで10バイトの領域を初期化できるよう，
ST命令の格納アドレスがG2の値で1番地ずつずれていきます．
ずらすためにインデクスモードを使用しました．
\begin{center}
{\small\tt
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 10 11 &      & LD   & G0,A          \\
02 & 17 0A &      & LD   & G1,\#10       \\
04 & 1B 00 &      & LD   & G2,\#0        \\
06 & 22 12 & LOOP & ST   & G0,B,G2       \\
08 & 3B 01 &      & ADD  & G2,\#1        \\
0A & 47 01 &      & SUB  & G1,\#1        \\
0C & A4 10 &      & JZ   & STOP          \\
0E & A0 06 &      & JMP  & LOOP          \\
10 & FF    & STOP & HALT &               \\
11 & AA    & A    & DC   & 0AAH          \\
12 & 00 00 & B    & DS   & 10            \\
14 & 00 00 &      &      &               \\
16 & 00 00 &      &      &               \\
18 & 00 00 &      &      &               \\
1A & 00 00 &      &      &               \\
\hline
\end{tabular}
}
\end{center}

次に，このプログラムのフローチャートを示します．
イミディエイトモードとインデクスドモードを，
フローチャート上でどのように表現しているか，
よく確認してください．

%\begin{figure}
\begin{center}
\epsfxsize=3.5cm
%%\epsfysize=13.0cm
\myepsfbox{flowD.pdf}
%\caption{アドレッシング使用例}
%\label{addr}
\end{center}
%\end{figure}

%\vfill
\newpage
\subsubsection{問題}
\begin{enumerate}
\item これまでに出てきたプログラムを，
イミディエイトモードを使用して書き換えなさい．
\item A番地からの5バイトのデータの合計を，
B番地に求めるプログラムを作りなさい．
\item A番地からの5バイトのデータを，
B番地からの5バイトにコピーするプログラムを作りなさい．
\end{enumerate}

\newpage
\section{入出力}

\figref{chap5:kousei2}に示したTeCの構成のうち主記憶は，
LD，ST命令等を使用することでアクセスできることが分かりました．
ここで説明する入出力(Input Output=略して I/O)命令は，
入出力インターフェース回路(\figref{chap5:kousei2}「TeCの構成」を参照)を
アクセスするための命令です．
読み込みを行うIN命令，書き込みを行うOUT命令の2種類があります．

\subsection{I/Oマップ}
\label{iomap}

いくつか存在するインターフェース回路の中の，
どれをアクセスするかはI/Oアドレス(メモリアドレスとは別のもの)に
より指定します．
TeCのI/Oアドレスは$0_{16}$〜$F_{16}$までの16番地です．
I/Oアドレスの一覧を「I/Oマップ」と言います．
「I/Oマップ」は次の表のようなものです．
%I/Oマップを通して見たインターフェース回路のことを，
%「I/Oポート」と呼びます．

\begin{center}
{\small
\begin{tabular}{| l | l | l |}
\hline
\multicolumn{3}{|c|}{I/Oマップ} \\
\hline
番地 & \multicolumn{1}{|c|}{Read} & \multicolumn{1}{|c|}{Write} \\
\hline
0    & データスイッチ   & ブザー \\
1    & データスイッチ   & スピーカ \\
2    & SIO受信データ    & SIO送信データ \\
3    & SIOステータス    & SIOコントロール \\
4(*) & タイマ現在値     & タイマ周期 \\
5(*) & タイマステータス & タイマコントロール \\
6(*) & 空き             & INT3コントロール \\
7(*) & 入力ポート       & 出力ポート \\
8(*) & ADC CH0          & 空き \\
9(*) & ADC CH1          & 空き \\
A(*) & ADC CH2          & 空き \\
B(*) & ADC CH3          & 空き \\
C    & 空き             & 空き \\
D    & 空き             & 空き \\
E    & 空き             & 空き \\
F    & 空き             & 空き \\
\hline
\end{tabular}
注：(*)はTeC6には搭載されていない機能を表す．
}
\end{center}

この表から，例えば次のことが分かります．(詳しくは，後の方で説明します．)
\begin{enumerate}
\item 0番地のRead(読み込み)により，データスイッチの値を読み込むことができる．
\item 0番地のWrite(書き込み)により，ブザーにアクセスできる．
\item 1番地のRead(読み込み)でも，データスイッチの値を読み込むことができる．
\item 1番地のWrite(書き込み)により，スピーカーにアクセスできる．
\item 2,3番地は，SIO(シリアル入出力)を用いてPCと通信するために使用される．
\item 4,5番地は，タイマを使用して時間を計るために使用される．
\item 6番地は，コンソールパネルから発生するINT3割込を制御する．
\item 7番地は，入出力ポートの値を読み書きするために使用される．
\item 8,9,A,B番地は，ADC(A/Dコンバータ：電圧を計測して数値に変換する回路)の
値を読み取るために使用される．
\item C,D,E,F番地は使用されない．
\end{enumerate}

I/Oマップは命令表の中にも掲載されていますので，確認してください．

%----------------------------------------------------------------------------
\subsection{IN(Input)命令}

\begin{description}
\item[意味：]入出力インターフェース回路からデータをレジスタに入力します．
I/Oアドレスは4ビットで指定します．

\item[ニーモニック：]{\tt IN  GR,P} \\
{\tt GR}は，値を入力するレジスタを表します．
{\tt P}は入出力インターフェース回路のアドレスです．

\item[命令フォーマット：]IN命令は2バイトの長さを持ちます．
XRフィールドは必ず$00$にします．
第2バイトの上位4ビットも必ず$0000$にします．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1100_2$ & $GR$~$00$ & 0000 pppp \\
\hline
\end{tabular}

\item[フローチャート：]IN命令は次のように描くことにします．
「動作の説明」は，各自が工夫して下さい．

\begin{flushleft}
\epsfxsize=3cm
\myepsfbox{in.pdf}
\end{flushleft}

\item[使用例：]
次のプログラムはデータスイッチの状態をI/Oアドレス0番地から読み取り，
G0レジスタに格納するものです．
ロータリースイッチをG0に合わせた状態で，
プログラムを実行してください．
データスイッチを変化させると即座にデータランプの表示が変化します．

プログラムは無限ループになっているので，
実行を開始したらSTOPボタンを押すまで止まりません．

\begin{center}
{\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
START & IN   & G0,0    \\
      & JMP  & START   \\ 
\hline
\end{tabular}
}
\end{center}

フローチャートで描くと，次のようになります．

\begin{center}
\epsfxsize=3.8cm
\myepsfbox{flowI.pdf}
\end{center}


\item[IN命令の応用：]
次のプログラムは，
データスイッチから数値を入力し，
合計をG0に求めるものです．
ロタリースイッチをG0に合わせて実行すると，
2進数入力，2進数表示の簡単な電卓として使用できます．

操作手順は次の通りです．

\begin{enumerate}
\item プログラムを入力する．
\item PCにプログラムの実行開始番地をセットする．
\item ロータリースイッチをG0に合わせる．
\item データスイッチにデータをセットする．
\item RUNボタンを押す．
\item データの件数分，4，5を繰り返す．
\item データランプに合計が表示されている．
\end{enumerate}

\begin{center}
{\tt 
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
START & LD   & G0,\#0        \\
LOOP  & IN   & G1,00H        \\
      & ST   & G1,TMP        \\
      & ADD  & G0,TMP        \\
      & HALT &               \\
      & JMP  & LOOP          \\ 
\hline
\end{tabular}
}
\end{center}

\end{description}

%----------------------------------------------------------------------------
\newpage
\subsection{OUT(Output)命令}
\label{out}

\begin{description}
\item[意味：]レジスタのデータを，
入出力インターフェース回路へ出力します．
I/Oアドレスは4ビットで指定します．

\item[ニーモニック：]{\tt OUT  GR,P} \\
{\tt GR}は，値を出力するレジスタを表します．
{\tt P}は入出力インターフェース回路のアドレスです．

\item[命令フォーマット：]OUT命令は2バイトの長さを持ちます．
XRフィールドは必ず$11$にします．
第2バイトの上位4ビットも必ず$0000$にします．

\begin{tabular}{|c|c|c|} \hline
\multicolumn{2}{|c|}{第1バイト} & \lw{第2バイト} \\
\cline{1-2}
OP & GR XR & \\
\hline
$1100_2$ & $GR$~$11$ & 0000 pppp \\
\hline
\end{tabular}

\item[使用例：]
次のプログラムはデータスイッチの値を読み取り，
ブザー用のポートに出力するものです．

ブザーは次の図のような構造になっており，
I/Oアドレス0番地に書き込んだ値で鳴ったり止まったりします．
プログラム実行中に，
データスイッチを操作して最下位ビットを1にするとブザーが鳴ります．
逆に最下位ビットを0にするとブザーの音が止まります．

プログラムは無限ループになっているので，
実行を開始したらSTOPボタンを押すまで止まりません．
ブザーが鳴っている状態でプログラムを停止しても，
ブザーが鳴りっぱなしになります．
その場合は，RESETスイッチを押して下さい．

\begin{center}
{\tt
\begin{tabular}{|l|l l|l}
\cline{1-3}
ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
START & IN   & G0,00H  \\
      & OUT  & G0,00H  \\
      & JMP  & START   \\ 
\hline
\end{tabular}
}
\end{center}

%\begin{figure}
\begin{center}
\epsfxsize=6cm
%%\epsfysize=13.0cm
\myepsfbox{buz1.pdf}
%\caption{ブザー}
%\label{buz1}
\end{center}
%\end{figure}

\end{description}


%----------------------------------------------------------------------------
\newpage
\section{TeCパラレル入出力(PIO)}
\label{pio}

TeC7には，基板上の入出力ポートコネクタ(\figref{chap4:kakubu}参照)を通して
8ビットデータを並列に入力・出力するパラレル入出力
(Parallel Input Output : 略して{\bf PIO})機能があります．
次の写真はPIOを使用し，
ブレッドボード上のLEDをプログラムで点灯・消灯できるようにした例です．

%\begin{figure}
\begin{center}
\epsfxsize=6.5cm
%%\epsfysize=13.0cm
\myepsfbox{expand.jpg}
%\caption{PIO}
%\label{buz1}
\end{center}
%\end{figure}

下に入出力ポートコネクタのピン配置図を示します．
I/Oアドレスの7番地にOUT命令で書込んだ2進数データがコネクタの$O_7$〜$O_0$に
出力されます．(対応するビットの``1''が3.3V，``0''が0Vになります．)
I/Oアドレスの7番地をIN命令で読むとコネクタの$I_7$〜$I_0$に入力された
電圧に対応したデータを入力できます．

入出力ポートコネクタの``0V''ピンはTeC7のGNDに接続されています．
``3V''ピンはTeC7の3.3V電源に接続されています．
外部に接続した回路の電源として使用することができます．

%\begin{figure}
\begin{center}
\epsfxsize=5.5cm
%%\epsfysize=13.0cm
\myepsfbox{pio.pdf}
%\caption{PIO}
%\label{buz1}
\end{center}
%\end{figure}

上の写真では，ブレッドボードを用いて次図のように配線してあります．
ポートに``0''を出力するとLEDが光ります．

%\begin{figure}
\begin{center}
\epsfxsize=4cm
%%\epsfysize=13.0cm
\myepsfbox{haisen.pdf}
%\caption{PIO}
%\label{buz1}
\end{center}
%\end{figure}

%----------------------------------------------------------------------------
\newpage
\section{TeCアナログ入力(AIN)}
\label{ain}

TeC7には，基板上の入出力ポートコネクタ(\figref{chap4:kakubu}参照)を通して
アナログ電圧値を入力できる機能(Analog INput : 略して {\bf AIN})があります．
TeC7のAINには，同時に4つのアナログ電圧が入力できます．

アナログ電圧は入出力ポートコネクタの
$I_3$，$I_2$，$I_1$，$I_0$ピンから入力します．
入力電圧は，0V〜3.3Vを256等分した数値(0V=0，3.3V=255)に変換されます．
数値に変換された結果は，I/Oアドレス8H〜BHで読み取ることができます．
次の表に，入力ピンとI/Oアドレスの対応をまとめます．

\begin{center}
\begin{tabular}{|c|l|l|}
\hline
I/O番地 & \multicolumn{1}{|c|}{名称} & \multicolumn{1}{|c|}{入力ピン} \\
\hline
8 & ADC CH0  & $I_0$ \\
9 & ADC CH1  & $I_1$ \\
A & ADC CH2  & $I_2$ \\
B & ADC CH3  & $I_3$ \\
\hline
\end{tabular}
\end{center}

入出力ポートコネクタの$I_3$，$I_2$，$I_1$，$I_0$ピンは，
パラレル入力にもアナログ入力にも使用されます．
パラレル入力ポートから見ると，
入力電圧が1.6V付近を境界に``0''と``1''が切り替わります．

次にアナログ電圧を入力する配線例を示します．
可変抵抗器を変化させることで入力値が変化することが確認できます．
入力値をプログラムが読み取るためには，
I/Oアドレスの8H番地(ADC CH0)をIN命令で読みます．

%\begin{figure}
\begin{center}
\epsfxsize=4cm
%%\epsfysize=13.0cm
\myepsfbox{haisen1.pdf}
%\caption{PIO}
%\label{buz1}
\end{center}
%\end{figure}

\vfill
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf PIOとAINはTeC6では使用できません．}

TeC6にもTeC7の入出力ポートとよく似たコネクタがあります．
このコネクタは「拡張コネクタ」と呼ばれ，
TeC6の内部バスが直接接続されたものです．
拡張コネクタを使用すると外部に入出力インタフェース回路を増設でき
TeC7よりも柔軟に外部回路の追加ができますが，
外部回路はTeC6の内部バスと通信できる複雑なものになります．
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\section{TeCシリアル入出力(SIO)}
\label{sio}
TeCには，
パソコンと接続できるシリアル入出力(Serial Input Output : 略して {\bf SIO})
インターフェースが備えてあります．

前出のIN，OUT命令を使用して，
SIOインターフェースにアクセスします．

%----------------------------------------------------------------------------
\subsection{シリアル入出力}
名前の通り(Serial＝直列)データを1ビット毎，転送する方式です．
次の図のように，時間による電圧の変化としてデータを表現します．
また，1ビットの時間として$1/9600$秒を用います．
$1/9600$秒で1ビットを送る通信速度を9600bau(ボー)と言います．

\begin{center}
\epsfxsize=7.5cm
\myepsfbox{serial0.pdf}
\end{center}

%----------------------------------------------------------------------------
\subsection{PCとの接続(TeC7の場合)}
PCと接続するときは，TeC7の電源コネクタとPCのUSBコネクタを接続します．
これで，PCから電源が供給されると同時にシリアル通信も可能になります．
なお，通信機能を使用するにはPCのOSに適切なドライバソフトが
インストールされている必要があります．
(TeC7には「USBシリアル変換IC」として，
FTDI社のFT232RLが実装されています．
PCにFT232RL用のドライバソフトをインストールして下さい．)

次の図にシリアル通信をするときのPCとTeC7の関係を示します．
FT232RLとTeC7のSIOインタフェース回路の間がシリアル通信部分になります．
TeC7のプログラムはSIOインタフェース回路を操作するだけなので，
その先にFT232RLやUSBケーブルがあることは分かりません．
TeC7のプログラムからは，後述のTeC6のシリアル入出力と全く同じに見えます．

%\begin{figure}
\begin{center}
\epsfxsize=7.5cm
%%\epsfysize=13.0cm
\myepsfbox{serial6.pdf}
%\caption{USB接続}
%\label{shft1}
\end{center}
%\end{figure}

%----------------------------------------------------------------------------
\subsection{PCとの接続(TeC6の場合)}
PCと接続するときは，TeC6の「RS-232Cコネクタ」と
PCの裏にあるRS-232Cコネクタを{\bf クロスケーブル}で接続します．
クロスケーブルで接続することにより，
PCの送信データとTeCの受信データ，
TeCの送信データとPCの受信データが接続され双方向の通信ができるようになります．
次の図にシリアル通信をするときのPCとTeC6の関係を示します．

%\begin{figure}
\begin{center}
\epsfxsize=7.5cm
%%\epsfysize=13.0cm
\myepsfbox{serial2.pdf}
%\caption{クロスケーブル}
%\label{shft1}
\end{center}
%\end{figure}

%\subsection{入出力用のコネクタ}
%TeC6は「RS-232Cコネクタ」をシリアル入出力用に使用します．
%RS-232Cコネクタのことを「シリアルポート」と呼ぶこともあります．
%TeC6は，RS-232Cコネクタの3本の信号線を次の図のように使用します．

%\begin{figure}
%\begin{center}
%\epsfxsize=7.5cm
%%\epsfysize=13.0cm
%\myepsfbox{serial1.pdf}
%\caption{RS-232Cポート}
%\label{shft1}
%\end{center}
%\end{figure}

%----------------------------------------------------------------------------
%\begin{center}
%\fbox{\parbox{7.5cm}{
%{\bf クロスケーブル} \\
%TeC6とPCを接続するために使用するクロスケーブルについて説明します．
%
%クロスケーブルは，写真のようなケーブルです．
%ケーブルの内部では，図のように配線が交差(クロス)しています．
%
%このような配線になっているので，
%TeC6の送信データのピンとPCの受信データピン，
%PCの送信データのピンとTeC6の受信データピンが接続され，
%TeC6とPCの間で双方向のデータ通信が可能になります．
%
%\begin{figure}
%\begin{center}
%\epsfxsize=7.5cm
%%%\epsfysize=13.0cm
%\myepsfbox{rs232c.pdf}
%%\caption{クロスケーブル}
%%\label{shft1}
%\end{center}
%%\end{figure}
%
%%\begin{figure}
%\begin{center}
%\epsfxsize=7.5cm
%%%\epsfysize=13.0cm
%\myepsfbox{serial2.pdf}
%%\caption{クロスケーブル}
%%\label{shft1}
%\end{center}
%\end{figure}
%}}
%\end{center}

%----------------------------------------------------------------------------
\vfill
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 定数の定義(EQU命令)} \\
IN命令の使用例や応用例で示したプログラムでは，
データスイッチの値を読み込むためのI/Oアドレス``0''が，
プログラム中に直接書いてありました．
データスイッチのことだと分かりやすい
名前を用いるとプログラムが読みやすくなります．
EQU命令は，名前(ラベル)を定義するための命令です．
EQU命令のオペランドの値を，ラベルに割り付けます．
他の命令と異なり，機械語やデータを生成しません．

{\tt
\begin{center}
\begin{tabular}{|c|l|l|l l|l}
\hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 &       & DSW   & EQU  & 00H     \\
00 & C0 00 & START & IN   & G0,DSW  \\
02 & A0 00 &       & JMP  & START   \\ 
\hline
\end{tabular}
\end{center}
}
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\subsection{I/Oポート}
\label{sioport}

SIOのI/Oポートは，2番地，3番地に配置されています(I/Oマップ参照)．
内容は次の通りです．

\begin{enumerate}
\item 受信データ \\
2番地をIN命令で読むと受信データを読み出すことができます．

\item 送信データ \\
2番地にOUT命令で送信データを書き出すことができます．

\item ステータス \\
3番地をIN命令で読むと次図のようなデータを読み込むことができます．
各ビットの意味も図の通りです．

\begin{center}
\epsfxsize=4.7cm
\myepsfbox{serial3.pdf}
\end{center}

プログラムは次の手順でステータスを調べ，
データの入出力が可能か判断します．
この判断は頻繁に使用するので，
フローチャートを次のように簡単化して描くことにします．

\begin{center}
\epsfxsize=6.8cm
\myepsfbox{serial5.pdf}
\end{center}

\item コントロール \\
3番地へOUT命令で次図のようなデータを書き込みます．
現在のところこの機能は使用しません．
詳細は，6章で説明します．

\begin{center}
\epsfxsize=5cm
\myepsfbox{serial4.pdf}
\end{center}

\end{enumerate}

%----------------------------------------------------------------------------
\newpage
\subsection{シリアル出力プログラム}
シリアル出力を行うプログラムの，
一般的なフローチャートを次の図に示します．
I/Oアドレス3番地の「Tビット」が``1''になり，
送信可能になるのを待って出力データを2番地に書き込みます．
Tビットが1か0か調べるために，AND命令を使用しています．
これで，(TeCがPCとケーブルで接続してあれば，)
2番地に書き込んだデータがPCに送信されます．

\begin{center}
\epsfxsize=7cm
\myepsfbox{flow6.pdf}
\end{center}

%----------------------------------------------------------------------------
\subsection{シリアル入力プログラム}
シリアル入力を行うプログラムの，
一般的なフローチャートを次の図に示します．
I/Oアドレス3番地の「Rビット」が``1''になり，
受信データが届くのを待って2番地からデータを読み込みます．
受信したデータは，G0に格納されます．

%\begin{figure}
\begin{center}
\epsfxsize=7cm
%%\epsfysize=13.0cm
\myepsfbox{flow7.pdf}
%\caption{読み込みアルゴリズム}
%\label{shft1}
\end{center}
%\end{figure}

%----------------------------------------------------------------------------
\vfill
\begin{center}
{\small
\fbox{\parbox{7.3cm}{
{\bf ターミナルプログラム} \\
\label{terminal}
UNIXまたはMacOSの{\bf screenプログラム}や{\bf tipプログラム}，
Windowsの{\bf ハイパーターミナル}等がターミナルプログラムの一種です．
ターミナルプログラムは，
シリアルポートから受信したデータをASCII文字コードとみなし，
対応する文字を画面に表示します．
また，キーボードが押されると，押された文字のASCII文字コードを
シリアルポートへ送信します．

TeCのSIOを使用するときは，
TeCとPCをケーブルで接続するだけでなく，
PCにターミナルプログラムを起動し，
PCのシリアルポートが使用できるように準備する必要があります．
}}}
\end{center}

%----------------------------------------------------------------------------
\subsection{シリアル入出力データ}
TeCがPCと通信するときは，
「\ref{char} 文字の表現」で勉強した ASCII コードを使用する約束とします．
PCのキーボードを叩くと，対応する文字の文字コードがTeCに送信され，
TeCが文字コードを送信すると，対応する文字がPCの画面に表示されます．
(PC側には，
このように動作する{\bf ターミナルプログラム}を動かしておく必要があります．)

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf ASCII文字コード表}\\
ASCII文字コード表は「\ref{char} 文字の表現」で勉強しました．
確認のためコード表を再度掲載します．

\epsfxsize=7cm
%\epsfysize=22.5cm
\myepsfbox{ascii.pdf}

}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf ニーモニック中の文字データ表記}

文字を扱うプログラムを書くとき，文字コードが必要になります．
そのときは，ニーモニック中に数値の代わりに，
「{\tt 'A'}」のように書くことができます．
文字{\tt A}の文字コード({\tt 41H})と言う意味です．
(文字コードにはASCIIコードを用います．)

ニーモニック中の{\tt 'A'}は，
{\tt 41H}または{\tt 65}と書いたのと全く同じ意味になります．

DC命令では，連続した文字の定義に{\tt "文字列"}を使用できます．
下のプログラム中にあるように，
{\tt "TeC"}の表記で3バイトのデータが生成されます．

{\tt
\begin{center}
\begin{tabular}{|c|l|l|l l|l}
\hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
00 & 13 41 & START & LD   & G0,\#'A'        \\
02 & FF    &       & HALT &                 \\ 
03 & 42 43 &       & DC   & 'B','C'         \\ 
05 & 45 65 &       & DC   & "TeC"           \\ 
07 & 43    &       &      &                 \\
\hline
\end{tabular}
\end{center}
}}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf ターミナルプログラム画面の改行} \\
ターミナルプログラムの表示を改行するには，
復帰コード(CR)と改行コード(LF)の2文字をTeCからPCへ送るのが一般的です．

復帰コード(CR:文字コードは0DH)は
文字カーソルを左端に移動するための文字，
改行コード(LF:文字コードは0AH)は
文字カーソルを一行下に移動するための文字です．

しかし，実際にUNIXのtipプログラムで試してみると，
改行コードのみの送信で復帰と改行の両方ができてしまいました．
(復帰コードを送っても害はありません．)

ターミナルプログラムにより，
必要な復帰コードと改行コードの組合せが変化するようです．
自分が実際に使用するシステムに合わせて，
臨機応変に対応してください．
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-7} 文字列出力1
\label{rei:5_7}
\begin{description}
\item[問題：] SIOへローマ字で自分の名前を出力するプログラムを作りなさい．

\item[考え方：]
筆者の場合，{\tt SHIGEMURA}の9文字を出力するプログラムを作成します．
データとして準備した9文字を，
インデクスドモードのアドレッシングを使用し順に出力します．

\item[フローチャート：]
次のようになります．
%\begin{figure}
\begin{center}
\epsfxsize=2.8cm
%%\epsfysize=13.0cm
\myepsfbox{flow8.pdf}
%\caption{文字列出力}
%\label{shft1}
\end{center}
%\end{figure}

\item[プログラム：]
\end{description}
\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &        & SIOD   & EQU    & 02H            \\
03 &        & SIOS   & EQU    & 03H            \\
00 &        &        &        &                \\
00 & 17 00  & START  & LD     & G1,\#0         \\
02 & 1B 09  &        & LD     & G2,\#9         \\
04 & C0 03  & LOOP   & IN     & G0,SIOS        \\
06 & 63 80  &        & AND    & G0,\#80H       \\
08 & A4 04  &        & JZ     & LOOP           \\
0A & 11 17  &        & LD     & G0,DATA,G1     \\
0C & C3 02  &        & OUT    & G0,SIOD        \\
0E & 37 01  &        & ADD    & G1,\#1         \\
10 & 4B 01  &        & SUB    & G2,\#1         \\
12 & A4 16  &        & JZ     & END            \\
14 & A0 04  &        & JMP    & LOOP           \\
16 &        &        &        &                \\
16 & FF     & END    & HALT   &                \\
17 &        &        &        &                \\
17 & 53 48  & DATA   & DC     & "SHIGEMURA"    \\
19 & 49 47  &        &        &                \\
1B & 45 4D  &        &        &                \\
1D & 55 52  &        &        &                \\
1F & 41     &        &        &                \\
\hline
\end{tabular}
}
\end{center}
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-8} 文字列出力2
\label{rei:5_8}
\begin{description}
\item[問題：] SIOへローマ字で``Tokuyama Kousen''，
``Shigemura''のような2行を出力するプログラムを作りなさい．

\item[考え方：]
繰り返しにより，1文字ずつSIOへ出力します．
1行目データと2行目データの間に，復帰コードと改行コードを置きます．
これらのコードも通常の文字と同じように扱って構いませんので，
プログラムは2行分を一気に出力するもので構いません．

\item[プログラム：]
プログラムにすると次のようになります．
データの最後の 00H は，データの終わりを示す目印です．
文字コードが 00H の文字は通常使用しませんので，
これを文字ではなく終わりの印に使用しました．

この方法だと，
出力するデータの長さが変化してもプログラムを変更する必要がありません．

\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &         &  SIOD  &  EQU    & 02H            \\
03 &         &  SIOS  &  EQU    & 03H            \\
00 &         &        &         &                \\
00 &  17 00  &        &  LD     & G1,\#0         \\
02 &  19 15  &  L0    &  LD     & G2,DATA,G1     \\
04 &  5B 00  &        &  CMP    & G2,\#0         \\
06 &  A4 14  &        &  JZ     & END            \\
08 &  C0 03  &  L1    &  IN     & G0,SIOS        \\
0A &  63 80  &        &  AND    & G0,\#80H       \\
0C &  A4 08  &        &  JZ     & L1             \\
0E &  CB 02  &        &  OUT    & G2,SIOD        \\
10 &  37 01  &        &  ADD    & G1,\#1         \\
12 &  A0 02  &        &  JMP    & L0             \\
14 &         &        &         &                \\
14 &  FF     &  END   &  HALT   &                \\
15 &         &        &         &                \\
15 &  54 6F  &  DATA  &  DC     & "Tokuyama      \\
17 &  6B 75  &        &         &   Kousen"      \\
19 &  79 61  &        &         &                \\
1B &  6D 61  &        &         &                \\
1D &  20 4B  &        &         &                \\
1F &  6F 75  &        &         &                \\
21 &  73 65  &        &         &                \\
23 &  6E     &        &         &                \\
24 &  0D 0A  &        &  DC     & 0DH,0AH        \\
26 &  53 68  &        &  DC     & "Shigemura"    \\
28 &  69 67  &        &         &                \\
2A &  65 6D  &        &         &                \\
2C &  75 72  &        &         &                \\
2E &  61     &        &         &                \\
2F &  0D 0A  &        &  DC     & 0DH,0AH        \\
31 &  00     &        &  DC     & 00H            \\
\hline
\end{tabular}
}
\end{center}
\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\newpage
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-9} `A'〜`Z'の文字を表示
\label{rei:5_9}
\begin{description}
\item[問題：] SIOへ`A'〜`Z'の文字を連続して出力するプログラムを作りなさい．

\item[考え方：]
`A'〜`Z'の文字コードは連続しています(ASCII文字コード表参照)．
最初に`A'の文字コードをレジスタにロードしSIOへ出力します．
次に，レジスタに1加えて文字コードを増やします．
増やした結果は`B'の文字コードですので，それを出力します．
後は同様に`Z'の文字コードまで出力します．

\item[フローチャート：]
次の通りです．

%\begin{figure}
\begin{center}
\epsfxsize=3.5cm
%%\epsfysize=13.0cm
\myepsfbox{flowH.pdf}
%\caption{文字出力}
%\label{shft1}
\end{center}
%\end{figure}

\item[プログラム：]
G0レジスタを文字コードの格納に，
G1レジスタを「Tビット」のチェックに使います．
出力可能になったらG0の文字コードをSIOへ出力します．
出力した後で出力した文字を調べ，`Z'だっら終了します．

\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD  & EQU  & 02H             \\
03 &       & SIOS  & EQU  & 03H             \\
00 &       &       &      &                 \\
00 & 13 41 &       & LD   & G0,\#'A'        \\
02 & C4 03 & WAIT  & IN   & G1,SIOS         \\
04 & 67 80 &       & AND  & G1,\#80H        \\
06 & A4 02 &       & JZ   & WAIT            \\
08 & C3 02 &       & OUT  & G0,SIOD         \\
0A & 53 5A &       & CMP  & G0,\#'Z'        \\
0C & A4 12 &       & JZ   & OWARI           \\
0E & 33 01 &       & ADD  & G0,\#1          \\
10 & A0 02 &       & JMP  & WAIT            \\
12 & FF    & OWARI & HALT &                 \\
\hline
\end{tabular}
}
\end{center}
\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\begin{center}
\fbox{\parbox{7.3cm}{
{\bf 例題5-10} echoプログラム
\label{rei:5_10}
\begin{description}
\item[問題：] SIOから入力した文字を
そのままSIOへ送り返す(こだま)プログラムを作りなさい．

\item[考え方：]
STOPボタンが押されるまで終了しないプログラムを作ります．
\item[フローチャート：]
次のようなアルゴリズムでできるはずです．

%\begin{figure}
\begin{center}
\epsfxsize=3cm
%%\epsfysize=13.0cm
\myepsfbox{flow9.pdf}
%\caption{文字入出力}
%\label{shft1}
\end{center}
%\end{figure}

\item[プログラム：]
G0レジスタを文字コードの格納用に，
G1レジスタを「Rビット」，「Tビット」のチェック用に使います．
IN命令でG0へ読み込んだ文字コードを，
OUT命令で書き戻すことにより文字を送り返します．

\begin{center}
{\footnotesize\tt
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD  & EQU & 02H            \\
03 &       & SIOS  & EQU & 03H            \\
00 &       &       &     &                \\
00 & C4 03 & START & IN  & G1,SIOS        \\
02 & 67 40 &       & AND & G1,\#40H       \\
04 & A4 00 &       & JZ  & START          \\
06 & C0 02 &       & IN  & G0,SIOD        \\
08 & C4 03 & WAIT  & IN  & G1,SIOS        \\
0A & 67 80 &       & AND & G1,\#80H       \\
0C & A4 08 &       & JZ  & WAIT           \\
0E & C3 02 &       & OUT & G0,SIOD        \\
10 & A0 00 &       & JMP & START          \\
\hline
\end{tabular}
}
\end{center}
\end{description}
}}
\end{center}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
%\begin{enumerate}
%\item SIOから1文字入力し，`*'を送り返すプログラムを作りなさい．
%\item
SIOから1文字入力し，
入力した文字がアルファベット小文字の場合大文字に変換し，
そうでなければそのままSIOへ出力するプログラムを作りなさい．
%\end{enumerate}
